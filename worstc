#!/usr/bin/env sh
exec cargo run -- "$0" --worstc "$0" "$@"
!#

[] quote wrap-definition add-definition

; 'name [program...] define%
[ wrap-definition 1 dig quote add-definition uplevel ]
quote define% add-definition

[ 1 dig quote add-definition uplevel ]
quote define%quiet add-definition

[ ; define
  quote quote uplevel ; name
  quote quote uplevel ; [def ...]
  quote define% uplevel
] quote define add-definition

[ ; define/q
  quote quote uplevel ; name
  quote quote uplevel ; [def ...]
  quote define%quiet uplevel
] quote define/q add-definition

define/q ' [quote quote uplevel]
define/q ^' ['quote 'uplevel uplevel]
define/q ^: [^' 'uplevel uplevel]

define swap [1 dig]

define/q prints [string->u8vector standard-output-port 1 dig port-write drop]
define/q printe [string->u8vector standard-error-port 1 dig port-write drop]

; cond [if-true ...] [if-false ...] if%
define/q if% [
    swap 2 dig      ; cond true-arm false-arm
    ; either
    ; true T F -> F T drop -> T
    ; false T F -> T F drop -> F
    'swap call-when drop
    eval-definition
]

define/q swapvar [
    ^' swap make-place
    [swap place-swap swap drop] swap list-push-head
    'define%quiet uplevel
]

[] swapvar %%history

; Mildly hacky global variable called on error
define/q %%failure [
    stack-empty? [
        "History:\n" printe
        0 %%history datum-describe->string printe "\n" printe
        interpreter-clear
    ] [
        datum-describe->string printe "\n" printe
        drop
        %%failure
    ] if%
]

define/q %history-push [
    [] %%history
    ^' list-push-tail
    ; list-length 20 greater-than 2 negate dig drop drop [] [list-pop-head drop] if%
    %%history drop
]

define/q wrap-definition [
    ; TODO push history; maybe stack control
    ; but make sure it doesn't interfere with TCO
    ; "Define " printe 1 dig datum-describe->string printe "\n" printe
    ; def name
    1 dig clone 2 negate dig
    ; ; name def name
    list-push-head
    '%history-push list-push-head
]

define/q eval [eval-definition]
define/q eval-file [ read-file eval ]

define/q local [
    [quote] swap list-push-tail
    ^' swap ^: define%quiet
]

0 1 equal? local false drop drop
0 0 equal? local true drop drop
define/q false? [false equal? swap drop]
define/q not [false? swap drop]
define/q true? [false? false? swap drop]

define/q equal?! [equal? swap drop]

; define/q not! [not swap drop]

define/q with-swapvar [
    ^' local %%swapvar-name
    [] %%swapvar-name call
    ^' eval
    %%swapvar-name call drop
]

; swapvar-take name => value
define/q swapvar-take [ false ^' call ]
define/q swapvar-set [ ^' call drop ]
define/q swapvar-get [
    ^' local %%swapvar-name
    [] %%swapvar-name call
    clone
    %%swapvar-name call drop
]

; cond if [if-true ...] [if-false ...]
define/q if [ ^' ^' if% ]

; body cond while%
define/q while% [
    '%cond swap define%quiet
    '%body swap define%quiet
    define/q %loop [ %cond [%body %loop] [] if% ]
    %loop
]
; while [-> bool] [body ...]
define/q while [
    ^' ^' swap while%
]

; cond [[if1] [body1] [if2] [body2] ...]
define/q cond [
    ^' swapvar conds%
    define/q next-cond% [
        with-swapvar conds% [
            list-empty?
            if [drop "cond clause exhausted" abort] []
            list-pop-head swap
        ] ^: eval
        if [
            with-swapvar conds% [list-pop-head swap] 'eval 'uplevel uplevel
            true
        ] [
            with-swapvar conds% [list-pop-head drop] false
        ]
    ]
    while [^: next-cond% not] []
]

define/q list-empty? [[] equal? swap drop]

[] swapvar program-arguments%

define/q program-argument [
    false swapvar shortopt
    false swapvar longopt
    define/q long [^' symbol->string longopt drop]
    'flag swapvar kind
    define/q flag ['flag kind drop ^' symbol->string shortopt drop]
    define/q arg ['arg kind drop ^' symbol->string shortopt drop]
    false swapvar doc-msg
    define/q doc [^' doc-msg drop]
    false swapvar isrequired
    ^' eval
    swapvar-take shortopt local shortopt
    swapvar-take longopt local longopt
    swapvar-take doc-msg local doc-msg
    swapvar-take kind local kind
    define/q + [ string-append ]
    shortopt
    longopt true? if [swap ", " + swap +] [drop]
        ": " +
        doc-msg +
        "\n" +
    local description
    with-swapvar program-arguments% [description list-push-tail]
    command-line
    while [list-pop-head "--worstc" equal?! not] [drop]
    drop
    local cmdline
    define/q findopt [
        local opt
        cmdline while [
            list-empty? if [false] [
                list-pop-head opt equal?! not
            ]
        ] [drop]
        list-empty? if [drop false] [true]
    ]
    cond [
        [shortopt findopt true?] []
        [drop longopt findopt true?] []
        [drop true] [false]
    ]
    cond [
        [not] [false]
        [kind 'arg equal?!] [
            drop swap list-empty? if [
                drop "No argument given for flag" abort
            ] [list-pop-head swap drop swap drop]
        ]
        ['flag equal?!] [drop drop drop true]
        [true] [abort]
    ]
]

define program-usage [
    swapvar-take program-arguments%
    while [list-empty? not] [
        list-pop-head prints
    ]
    drop
]

program-argument [
    doc "libworst directory (default ./lib)"
    arg -L
    long --lib-dir
]
"./lib" and if [drop] [swap drop] local lib-dir

program-argument [
    doc "Output file (default to standard output)"
    arg -o
]
local output-file

program-argument [
    doc "Input file (required)"
    arg -i
]
local input-file

program-argument [ flag -h long --help doc "Show help" ]
if [
    "worstc: Worst compiler\n" prints
    program-usage abort
] [
    ; output-file true? swap drop
    input-file false? swap drop
    if [program-usage abort] []
    ; and swap drop swap drop if [] [program-usage abort]
]

output-file true? if [
    make-open-file-options
    open-file-write open-file-create open-file-truncate
    output-file open-file
    file-port
] [ drop standard-output-port ]
local %output-port

define/q target [
    ^' symbol->string local t
    lib-dir
        "/target/" string-append
        t string-append
        ".w" string-append
    read-file
    ^: eval
]

define/q define/export [
    ^' ^'
    'define% 'uplevel uplevel
]

define/q export [
    ^' clone resolve-definition
    'define%quiet 'uplevel uplevel
]

input-file eval-file

;;; vi: ft=scheme

