#!/usr/bin/env sh
exec cargo run -- "$0" --worstc "$0" "$@"
!#

[] quote wrap-definition add-definition

; 'name [program...] define%
[ wrap-definition 1 dig quote add-definition uplevel ]
quote define% add-definition

[ 1 dig quote add-definition uplevel ]
quote define%quiet add-definition

[ ; define
  quote quote uplevel ; name
  quote quote uplevel ; [def ...]
  quote define% uplevel
] quote define add-definition

[ ; define/q
  quote quote uplevel ; name
  quote quote uplevel ; [def ...]
  quote define%quiet uplevel
] quote define/q add-definition

define/q ' [quote quote uplevel]
define/q ^' ['quote 'uplevel uplevel]
define/q ^: [^' 'uplevel uplevel]

define swap [1 dig]

define prints [string->u8vector standard-output-port 1 dig port-write drop]
define printe [string->u8vector standard-error-port 1 dig port-write drop]

define wrap-definition [
    ; TODO push history; maybe stack control
    ; but make sure it doesn't interfere with TCO
    "Defining " printe
    swap datum-describe->string printe
    "\n" printe
    swap
]

; Mildly hacky global variable called on error
define %%failure [
    while [stack-empty? not] [
        datum-describe->string printe "\n" printe
        drop
    ]
    interpreter-clear
]

define eval [eval-definition]
define ^eval-file [^: load-file]
define eval-file [load-file]

define local [
    [quote] swap list-push-tail
    ^' swap ^: define%
]

define local/q [
    [quote] swap list-push-tail
    ^' swap ^: define%quiet
]

0 1 equal? local/q false drop drop
0 0 equal? local/q true drop drop
define false? [false equal? swap drop]
define not [false? swap drop]
define true? [false? false? swap drop]

define equal?! [equal? swap drop]

define swapvar [
    ^' swap make-place
    [swap place-swap swap drop] swap list-push-head
    'define% uplevel
]

define with-swapvar [
    ^' local/q %%swapvar-name
    [] %%swapvar-name call
    ^' eval
    %%swapvar-name call drop
]

; swapvar-take name => value
define swapvar-take [ false ^' call ]

; cond [if-true ...] [if-false ...] if%
define/q if% [
    swap 2 dig      ; cond true-arm false-arm
    ; either
    ; true T F -> F T drop -> T
    ; false T F -> T F drop -> F
    'swap call-when drop
    eval
]

; cond if [if-true ...] [if-false ...]
define if [ ^' ^' if% ]

; while [-> bool] [body ...]
define while [
    '%cond ^' define%
    '%body ^' define%
    define %loop [ %cond [%body %loop] [] if% ]
    %loop
]

; cond [[if1] [body1] [if2] [body2] ...]
define cond [
    ^' swapvar conds%
    define next-cond% [
        with-swapvar conds% [list-pop-head swap] ^: eval
        if [
            with-swapvar conds% [list-pop-head swap] 'eval 'uplevel uplevel
            true
        ] [
            with-swapvar conds% [list-pop-head drop] false
        ]
    ]
    while [^: next-cond% not] []
]

define list-empty? [[] equal? swap drop]

[] swapvar program-arguments%

define program-argument [
    false swapvar shortopt
    false swapvar longopt
    define long [^' symbol->string longopt drop]
    'flag swapvar kind
    define flag ['flag kind drop ^' symbol->string shortopt drop]
    define arg ['arg kind drop ^' symbol->string shortopt drop]
    false swapvar doc-msg
    define doc [^' doc-msg drop]
    false swapvar isrequired
    ^' eval
    swapvar-take shortopt local shortopt
    swapvar-take longopt local longopt
    swapvar-take doc-msg local doc-msg
    swapvar-take kind local kind
    define + [ string-append ]
    shortopt
    longopt true? if [swap ", " + swap +] [drop]
        ": " +
        doc-msg +
        "\n" +
    local description
    with-swapvar program-arguments% [description list-push-tail]
    command-line
    while [list-pop-head "--worstc" equal?! not] [drop]
    drop
    local cmdline
    define findopt [
        local opt
        cmdline while [
            list-empty? if [false] [
                list-pop-head opt equal?! not
            ]
        ] [drop]
        list-empty? if [drop false] [true]
    ]
    cond [
        [shortopt findopt true?] []
        [drop longopt findopt true?] []
        [drop true] [false]
    ]
    cond [
        [not] [false]
        [kind 'arg equal?!] [
            drop swap list-empty? if [
                drop "No argument given for flag" abort
            ] [list-pop-head swap drop swap drop]
        ]
        ['flag equal?!] [drop drop drop true]
        [true] [abort]
    ]
]

define program-usage [
    swapvar-take program-arguments%
    while [list-empty? not] [
        list-pop-head prints
    ]
    drop
]

program-argument [
    doc "libworst directory (default ./lib)"
    arg -L
    long --lib-dir
]
"./lib" and if [drop] [swap drop] local lib-dir

program-argument [
    doc "Output format (default lua)"
    arg -O
    long --output-format
]
"lua" and if [drop] [swap drop] local output-format

program-argument [
    doc "Output file (required)"
    arg -o
]
local output-file

program-argument [
    doc "Input file (required)"
    arg -i
]
local input-file

program-argument [ flag -h long --help doc "Show help" ]
if [
    "worstc: Worst compiler\n" prints
    program-usage abort
] [
    ; output-file true? swap drop
    input-file false? swap drop
    if [program-usage abort] []
    ; and swap drop swap drop if [] [program-usage abort]
]

output-file true? if [
    make-open-file-options
    open-file-write open-file-create open-file-truncate
    output-file open-file
    file-port
] [ drop standard-output-port ]
local %output-port

define + [ string-append ]
lib-dir
    "/target/" +
    output-format +
    ".w" +
^eval-file

input-file ^eval-file

;;; vi: ft=scheme

